
Last siggraph there was this raytracing paper, and it, combined with my shiny new Haswell laptop, inspired me to start messing around with raytracing again.  

First, a quick overview.  There has been a lot of research into accelerating ray tracing over the past few years.  Quite a few very different approaches have been developed to mapping the raytracing problem onto hardware in the most efficient way possible. There are too many variations on the technique for me to give a complete taxonomy here, but I'll review the most relevant techniques:

SINGLE RAY TRAVERSAL

The first way is the one we all learned in Graphics Kindergarten.  Trace individual rays, one at a time, through the acceleration structure.   Contrary to popular belief, the naive single-ray technique, properly implemented on modern CPUs, is NOT limited by the cost of intersection tests.  It is, rather, limited by cache misses.  Ray tracing makes a lot of irregular memory accesses as the way propagates down through the hierarchy, and the memory system just isnt' able to keep up.  State of the art single-ray traversal adapts to this by altering the acceleration structure.  

The so-called "QBVH" https://www.uni-ulm.de/fileadmin/website_uni_ulm/iui.inst.100/institut/Papers/QBVH.pdf is the current favorite, and it works by using a 4-ary tree instead of the more traditional binary tree.  Each node holds the bounding boxes of its four children, which are intersection tested 4 at a time using SIMD instructions.  The speedup from the QBVH has less to do with its use of SIMD and more to do with its memory access characteristics.  The QBVH ends up using less memory than a corresponding binary BVH, which brings with it a corresponding drop in memory bandwidth.

Unfortunately, as Wald et al found, increasing the 'arity' of the tree starts to hit diminishing returns as the SIMD width increases. 
http://www.sci.utah.edu/~wald/Publications/2008/Multi/multi.pdf


PACKET TRAVERSAL

Packet traversal works by grouping multiple rays into SIMD-sized groups, and walking all N rays down the tree simultaneously. In its most obvious form, N is chosen to be the SIMD width (4 for SSE, 8 for AVX, and so on), and the ray/node intersection tests are re-written to operate on N rays at a time in parallel.  Packet traversal can be further improved by using larger packet sizes and iterating over SIMD-sized groups at each node.
 
The advantage of packet traversal is that it amortizes the costly memory accesses over a large number of rays, which swings the algorithm from being memory-bound back towards being compute-bound.  The disadvantage of packet traversal is that requires a great deal of coherence between the rays in a packet in order to be effective.    Traversal continues down the tree until EVERY ray in the packet has missed a given node, and if all of the rays in a packet are going in very different directions, this can cause the packet traversal to degenerate into a more expensive version of single-ray traversal.


STREAMING TRAVERSAL

This is basically a variant of packet traversal, in which a very large packet is used, and rays which miss a bounding volume are gradually removed from consideration as the stream is walked down the tree.  Lauterbach's "partition traversal" is one example, and the 'Dynamic Ray Stream ' paper is another.  Streaming traversal tries to avoid the de-coherence problems of conventional packet traversal by attempting to throw so many rays down at once that any natural coherence in the ray set can be teased out and exploited.   


For my latest raytracer, I've tried to combine a partition-style scheme with adaptive ray packet re-ordering, a la this paper:
https://graphics.stanford.edu/~boulos/papers/reorder_rt08.pdf.  Since it's a side project and I can do whatever I please, I decided to give myself free reign to use the full instruction set of my Haswell laptop.  This means that AVX2, FMA, and all that other coolness is all on the table.


Given a large collection of rays, we begin by partitioning the rays by octant, where 'octant(r)' is the 3-bit integer formed by the sign bits of the ray directions.   Splitting rays by octant allows some of the comparisions to be amortized out of the ray-box intersection tests.  At each node of the tree, we intersect all of the rays with the node's bounding box, 8 at a time, and produce an 8-bit hit mask for each 8-ray group.  I found that I get better results by 2x unrolling this intersection loop and doing two packets at once.   Here's the code:


I use fmadd instructions for the box test, as did Barringer.  This turns out better than a mul/sub pair despite a higher operation count. 





